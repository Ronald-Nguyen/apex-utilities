Cognitive Complexity Reduction
Task Description
You are a strict code‑refactoring engine. You follow all rules exactly as written. Your task is to refactor code so that its cognitive complexity score is minimized while preserving behavior.

Please note:
1. The code must still function perfectly after the refactoring.
2. All imports, references, and function calls must be updated accordingly.
3. The style and formatting of the code must be preserved.
4. Do not introduce any new functionality, logic changes, or unrelated formatting changes.
5. For every modified file, return the complete updated file content to ensure that no changes are overlooked.
6. The semantics and behavior of the code must not change.
7. Only include files that require changes.
8. Respond with the code blocks only. Your entire response must be machine-readable. Do not include any conversational filler.
9. If you are unsure, do not guess. Only modify code when the change is certain.

Definitions:
Cognitive complexity increases with:
- Deeply nested control structures
- Multiple branching paths
- Boolean logic with many operators
- Long functions with mixed responsibilities
- Repeated condition checks
- Hard‑to‑follow flow or side effects

Cognitive complexity decreases with:
- Early returns instead of deep nesting
- Extracting helper functions
- Flattening conditionals
- Replacing complex boolean expressions with named variables
- Clear, linear control flow
- Removing duplication

Examples of cognitive complexity reduction tasks:
Example 1:
Original Code: 
File `process.py`:
```python
def process(items):
    result = []
    for item in items:
        if item.is_valid():
            if not item.is_expired():
                if item.value > 10:
                    result.append(item.value)
    return result
```
Task:
1. Refactor the following code to reduce cognitive complexity while preserving behavior.
2. For EACH modified file, respond exactly in the following format:
File `filename.py`:
```python
[Complete updated file content]

Output:
File `process.py`:
```python
def process(items):
    result = []
    for item in items:
        if not item.is_valid():
            continue
        if item.is_expired():
            continue
        if item.value <= 10:
            continue
        result.append(item.value)
    return result
```

Example 2:
Original Code: 
File `compute.py`:
```python
def compute(x, y, z):
    if x > 0:
        if y > 0:
            return x + y + z
        else:
            return x + z
    else:
        return z
```

Task:
1. Refactor the following code to reduce cognitive complexity while preserving behavior.
2. For EACH modified file, respond exactly in the following format:
File `filename.py`:
```python
[Complete updated file content]

Output:
File `compute.py`:
```python
def compute(x, y, z):
    if x <= 0:
        return z
    if y <= 0:
        return x + z
    return x + y + z
```

Task:
1. Choose only one method and reduce the cognitive complexity while preserving behavior.
2. For EACH modified file, respond exactly in the following format:
File `filename.py`:
```python
[Complete updated file content]

Struktur:
force-app/
  main/
    utilities/
      classes/
        DatabaseUtils.cls
        DateUtils.cls
        Stack.cls
      configuration-management/
        classes/
          ConfigurationManager.cls
          DeletionValidator.cls
        objects/
          Configuration__c/
            fields/
      logging/
        classes/
          EventBufferLogAdapter.cls
          LoggedQueueable.cls
          LoggedSchedulable.cls
          Logger.cls
          LoggerAdapter.cls
          LoggerFactory.cls
          LogMessage.cls
          LogWriter.cls
          QueueableScheduler.cls
        customMetadata/
        layouts/
        objects/
          Logging_Level__mdt/
          Log_Event__e/
            fields/
          Log__c/
            fields/
            listViews/
        permissionsets/
        profiler/
          classes/
            ApexProfiler.cls
            OrgLimitsProfiler.cls
            OrgLimitsProfilingReportRunner.cls
            Profiler.cls
          layouts/
          objects/
            Apex_Profiling_Warning_Limit__mdt/
              fields/
              validationRules/
        tabs/
        triggers/
          LogEventAfterInsert.trigger
      parsers/
        classes/
          DisplayTypeParser.cls
          Parsable.cls
      schema/
        classes/
          InvalidFieldException.cls
          PicklistValueSet.cls
          Relationship.cls
          SchemaFacade.cls
          SecureSObjectWrapper.cls
          SObjectRecordTypes.cls
          SObjectWrapper.cls
          StateCountryCodeMapper.cls
      string-utilities/
        classes/
          CsvBuilder.cls
          QueryBuilder.cls
          StringBuilder.cls
      trigger-framework/
        classes/
          SObjectTriggerWrapper.cls
          Triggerable.cls
          TriggerDispatcher.cls
          TriggerHandler.cls

Code:


File `main\utilities\classes\DatabaseUtils.cls`:
```apex

/**
 * @author Gavin Palmer
 * @date 2019-03-13
 * @description This class is a utility for the Database class
 *
 **/
public inherited sharing class DatabaseUtils {
    /**
     * @description This is the seperator to be used when concatenating the string, defaults to unix new line character
     */
    public static String errorStringSeperator = '\n';

    /**
     * @description This function will concatenate the errors output from the database actions
     * @param errors a list of database errors that are to be concatenated
     * @return a concatenated list of the errors passed into the function
     * @example
     * Database.SaveResult results = Database.insert(newAccount, false);
     * String errors = DatabaseUtils.getErrorString(results.getErrors());
     *
     **/
    public static String getErrorString(List<Database.Error> errors) {
        if (errors == null || errors.isEmpty()) {
            return '';
        }

        final StringBuilder fullErrors = new StringBuilder();
        fullErrors.setSeparator(errorStringSeperator);
        for (Database.Error error : errors) {
            fullErrors.append(error.getMessage());
        }
        return fullErrors.toString();
    }
}```


File `main\utilities\classes\DateUtils.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-03-11
 * @description This class will be used for reusable date functions
 *
 **/
public without sharing class DateUtils {
    private static Datetime now;
    private static Date today;

    /**
     * @description This method should be used be used in place of the standard datetime method, to allow date injection in test classes
     * @return The current datetime, or the one injected in a test method
     *
     **/
    public static Datetime getNow() {
        return now == null ? Datetime.now() : now;
    }

    /**
     * @description This method should be used be used in place of the standard date method, to allow date injection in test classes
     * @return The current date, or the one injected in a test method
     *
     **/
    public static Date getToday() {
        return today == null ? Date.today() : today;
    }

    @testVisible
    private static void setNow(Datetime newNow) {
        now = newNow;
    }

    @testVisible
    private static void setToday(Date newToday) {
        today = newToday;
    }

    /**
     * @description This function will return a date that is at the end of the month
     * @return A date at the end of the month
     *
     **/
    public static Date toEndOfMonth(final Date input) {
        final Integer lastDayOfMonth = Date.daysInMonth(input.year(), input.month());
        return Date.newInstance(input.year(), input.month(), lastDayOfMonth);
    }
}
```


File `main\utilities\classes\Stack.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-11-20
 * @description A simple stack implementation to allow FILO on data structures
 *
 **/
public class Stack {
    private final List<Object> items = new List<Object>();

    public void push(Object item) {
        items.add(item);
    }

    public Object pop() {
        if (isEmpty()) {
            throw new UnderflowException();
        }
        return items.remove(items.size() - 1);
    }

    public Integer size() {
        return items.size();
    }

    public Boolean isEmpty() {
        return items.isEmpty();
    }

    public override String toString() {
        return String.join(items, '\n');
    }

    public class UnderflowException extends Exception {
    }
}
```


File `main\utilities\configuration-management\classes\ConfigurationManager.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-06-27
 * @group Configuration Management
 * @description This uses a custom setting underneath that will allow callers to programatically disable triggers,
 * workflows, process builders and validation rules through code.
 * This requires all new configurations to include a catch as the first line so that they can all be
 * turned off. If you are using some form of a trigger framework the catch can be added in there so
 * that this doesn't need to be remembered by all developers when adding new triggers.
 * The class is mostly useful for turning off automation while setting up test data in
 * test classes so that you can fully test your classes
 *
 **/
public without sharing class ConfigurationManager {
    private final Configuration__c configurationSetting = Configuration__c.getInstance();

    private static final ConfigurationManager INSTANCE = new ConfigurationManager();

    public static ConfigurationManager getInstance() {
        return INSTANCE;
    }

    public static void turnAutomationsOn() {
        INSTANCE.turnProcessesOn();
        INSTANCE.turnTriggersOn();
        INSTANCE.turnValidationsOn();
        INSTANCE.turnWorkflowsOn();
        INSTANCE.commitChanges();
    }

    public static void turnAutomationsOff() {
        INSTANCE.turnProcessesOff();
        INSTANCE.turnTriggersOff();
        INSTANCE.turnValidationsOff();
        INSTANCE.turnWorkflowsOff();
        INSTANCE.commitChanges();
    }

    @SuppressWarnings('PMD.EmptyStatementBlock')
    private ConfigurationManager() {
    }

    public Boolean areTriggersOff() {
        return configurationSetting.Are_Triggers_Off__c;
    }

    public Boolean areTriggersOn() {
        return !areTriggersOff();
    }

    public Boolean isAllowedDelete() {
        return configurationSetting.Is_Allowed_Delete__c;
    }

    public Boolean isNotAllowedDelete() {
        return !isAllowedDelete();
    }

    public void turnTriggersOff() {
        configurationSetting.Are_Triggers_Off__c = true;
    }

    public void turnTriggersOn() {
        configurationSetting.Are_Triggers_Off__c = false;
    }

    public void turnWorkflowsOff() {
        configurationSetting.Are_Workflows_Off__c = true;
    }

    public void turnWorkflowsOn() {
        configurationSetting.Are_Workflows_Off__c = false;
    }

    public void turnValidationsOff() {
        configurationSetting.Are_Validations_Off__c = true;
    }

    public void turnValidationsOn() {
        configurationSetting.Are_Validations_Off__c = false;
    }

    public void turnProcessesOff() {
        configurationSetting.Are_Processes_Off__c = true;
    }

    public void turnProcessesOn() {
        configurationSetting.Are_Processes_Off__c = false;
    }

    public void turnDeletionOff() {
        configurationSetting.Is_Allowed_Delete__c = false;
    }

    public void turnDeletionOn() {
        configurationSetting.Is_Allowed_Delete__c = true;
    }

    public void commitChanges() {
        upsert configurationSetting;
    }
}
```


File `main\utilities\configuration-management\classes\DeletionValidator.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-02-11
 * @group Configuration Management
 * @description This class will be used to validate the deletion of objects
 * which are not covered by profiles (for example ContentVersions).
 * A delete trigger should be implemented on the object calling into this triggerable
 *
 **/
public without sharing class DeletionValidator extends Triggerable {
    @testVisible
    private static final String NOT_ALLOWED_DELETE = 'You do not have the correct permissions to delete this record. Please contact your system administrator';

    public override void register(SObjectTriggerWrapper wrappedSObject) {
        if (ConfigurationManager.getInstance().isNotAllowedDelete()) {
            wrappedSObject.getSObject().addError(NOT_ALLOWED_DELETE);
        }
    }
}
```


File `main\utilities\logging\classes\EventBufferLogAdapter.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-06-27
 * @group Logging
 * @description The bulk log object adapter can be used to insert logs as a custom object into the database,
 * as a singleton the write logs can be called at the end of a trigger to insert the full logs into the system only once per object
 * The class has been adapted to use events so that it can still insert log objects when a transaction is rolled back, allowing it
 * to be more robust in trigger contexts
 * Usage:
 * Logger log = LoggerFactory.createLogger(MyClass.class);
 * log.warn('A warning message');
 * log.close();
 *
 **/
public without sharing class EventBufferLogAdapter extends LoggerAdapter {
    @testVisible
    private static final String ERROR = 'Error';
    @testVisible
    private static final String WARNING = 'Warning';
    @testVisible
    private static final String INFO = 'Information';
    @testVisible
    private static final String DEBUG = 'Debug';

    private static final Integer MAX_LOG_BUFFER = 10;

    private static final EventBufferLogAdapter INSTANCE = new EventBufferLogAdapter();

    @testVisible
    private final List<Log_Event__e> logsToPublish = new List<Log_Event__e>();
    @testVisible
    private static final Set<String> LOGGING_LEVELS = new Set<String>();

    static {
        for (Logging_Level__mdt loggingLevel : [SELECT DeveloperName FROM Logging_Level__mdt]) {
            LOGGING_LEVELS.add(loggingLevel.DeveloperName);
        }
    }

    public static EventBufferLogAdapter getInstance() {
        return INSTANCE;
    }

    @SuppressWarnings('PMD.EmptyStatementBlock')
    private EventBufferLogAdapter() {
    }

    public override void log(Object logLevel, String message) {
        log(logLevel, message, null);
    }
    public override void log(Object logLevel, String message, Id recordId) {
        String logLevelString = (String) logLevel;
        if (LOGGING_LEVELS.contains(logLevelString)) {
            logsToPublish.add(createLogEvent(logLevelString, message, recordId));
        }
        if (logsToPublish.size() >= MAX_LOG_BUFFER) {
            close();
        }
    }
    private Log_Event__e createLogEvent(String logLevel, String message, Id recordId) {
        Request currentRequest = Request.getCurrent();
        return new Log_Event__e(
            Type__c = logType,
            Level__c = logLevel,
            Messages__c = message,
            Record_Id__c = recordId,
            Quiddity__c = currentRequest.getQuiddity().name(),
            Transaction_Id__c = currentRequest.getRequestId()
        );
    }
    public override Object errorLevel() {
        return ERROR;
    }
    public override Object warningLevel() {
        return WARNING;
    }
    public override Object infoLevel() {
        return INFO;
    }
    public override Object debugLevel() {
        return DEBUG;
    }
    public override void close() {
        if (!logsToPublish.isEmpty()) {
            // if error occurs allow to surface to the user as there is nothing else we can do here
            EventBus.publish(logsToPublish);
            logsToPublish.clear();
        }
    }
}
```


File `main\utilities\logging\classes\LoggedQueueable.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-02-06
 * @group Logging
 * @description This class wraps the queueable interface with the logging framework so that developers do not
 * have to worry about writing the logs after the Logger methods are called.
 *
 **/
public abstract inherited sharing class LoggedQueueable implements Queueable {
    protected QueueableContext context;
    protected final Logger log = LoggerFactory.createLogger(LoggedQueueable.class);

    /**
     * @description This is the implementation of the Queueable method, this does not need to be extended.
     * It adds the logging and general exception handling around the Queueable interface
     *
     **/
    public void execute(QueueableContext context) {
        this.context = context;
        try {
            execute();
        } catch (Exception exceptionToHandle) {
            log.error(exceptionToHandle);
        }
        log.close();
    }

    /**
     * @description This is the method that should be implemented, in a similar way to the Queueable interface
     *
     **/
    protected abstract void execute();

    /**
     * @description The enqueue method will set the queueable off for execution following the transaction
     *
     **/
    public Id enqueue() {
        return System.enqueueJob(this);
    }
}
```


File `main\utilities\logging\classes\LoggedSchedulable.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-03-11
 * @group Logging
 * @description This wraps the standard Schedulable interfaece and allows the logs to be written without developers needing to write the logs specifically
 *
 **/
public abstract inherited sharing class LoggedSchedulable implements Schedulable {
    private static final String DAILY_CRON_EXPRESSION = '0 0 0 ? * * *';
    public static final String DEFAULT_JOB_NAME = 'Schedule Job';

    protected SchedulableContext context;
    protected final Logger log = LoggerFactory.createLogger(LoggedSchedulable.class);
    private String jobName = DEFAULT_JOB_NAME;

    /**
     * @description This is the implementation of the Schedulable method, this does not need to be extended.
     * It adds the logging and general exception handling around the Schedulable interface
     *
     **/
    public void execute(SchedulableContext context) {
        this.context = context;
        try {
            execute();
        } catch (Exception exceptionToHandle) {
            log.error(exceptionToHandle);
        }
        log.close();
    }

    /**
     * @description This is the method that should be implemented, in a similar way to the Schedulable interface
     *
     **/
    protected abstract void execute();

    /**
     * @description this method will schedule the class on a daily basis at 00:00
     *
     **/
    public Id scheduleDaily() {
        return schedule(DAILY_CRON_EXPRESSION);
    }

    /**
     * @description This method allows the class to be scheduled, based on the cron expression
     *
     **/
    public Id schedule(String cronExpression) {
        return System.schedule(getJobName(), cronExpression, this);
    }

    /**
     * @description This method will set the job name to be used when schedule is called, if not set the default will be used
     *
     **/
    public void setJobName(String jobName) {
        this.jobName = jobName;
    }

    protected String getJobName() {
        return jobName;
    }
}
```


File `main\utilities\logging\classes\Logger.cls`:
```apex
/*
 * Copyright 2017-present Sirono LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author Gavin Palmer
 * @date 2018-06-27
 * @group Logging
 * @description The logger provides an extendable logging interface, the actual logging option can be easily switched by the use of the LoggerAdapter inner class.
 * This class was adapted from https://github.com/blueprinthealth/sirono-common/blob/master/src/classes/Logger.cls
 * Usage:
 * Logger log = new Logger(new DebugLogAdapter());
 * log.warn('A warning is here');
 * try {
 *     insert new Account();
 * } catch (DmlException exceptionToHandle) {
 *     log.error(exceptionToHandle);
 * }
 *
 **/
@SuppressWarnings('PMD.ExcessivePublicCount')
public without sharing class Logger {
    private static final String MESSAGE_FORMAT = 'An error has occured in the class {0} with the message: {1}';

    private final LoggerAdapter loggerAdapter;

    public Logger(Type apexClass, LoggerAdapter loggerAdapter) {
        this.loggerAdapter = loggerAdapter;
        this.loggerAdapter.setType(apexClass.getName());
    }

    public void setType(String type) {
        this.loggerAdapter.setType(type);
    }

    // Logger should somehow take a map of string to object to log more complex messages with fiels that can then be made searchable?
    public void debug(String messageToLog) {
        loggerAdapter.log(loggerAdapter.debugLevel(), (new LogMessage(messageToLog)).toString());
    }

    public void debug(String messageToLog, Id recordId) {
        loggerAdapter.log(
            loggerAdapter.debugLevel(),
            (new LogMessage(messageToLog)).toString(),
            recordId
        );
    }

    public void info(String messageToLog) {
        loggerAdapter.log(loggerAdapter.infoLevel(), (new LogMessage(messageToLog)).toString());
    }

    public void info(String messageToLog, Id recordId) {
        loggerAdapter.log(
            loggerAdapter.infoLevel(),
            (new LogMessage(messageToLog)).toString(),
            recordId
        );
    }

    public void warn(String messageToLog) {
        loggerAdapter.log(loggerAdapter.warningLevel(), (new LogMessage(messageToLog)).toString());
    }

    public void warn(String messageToLog, Id recordId) {
        loggerAdapter.log(
            loggerAdapter.warningLevel(),
            (new LogMessage(messageToLog)).toString(),
            recordId
        );
    }

    public void error(String messageToLog) {
        loggerAdapter.log(loggerAdapter.errorLevel(), (new LogMessage(messageToLog)).toString());
    }

    public void error(String messageToLog, Id recordId) {
        loggerAdapter.log(
            loggerAdapter.errorLevel(),
            (new LogMessage(messageToLog)).toString(),
            recordId
        );
    }

    public void error(Exception exceptionToLog) {
        error((new LogMessage(exceptionToLog)).toString());
    }

    public void error(Exception exceptionToLog, Id recordId) {
        error((new LogMessage(exceptionToLog)).toString(), recordId);
    }

    /*
     * @description this method should be called after the logs have been written,
     * the logger adapter will then close off any open transactions (or fire the events in the case of the <<EventBufferLogAdapter>>)
     */
    public void close() {
        runApexPofiling();
        loggerAdapter.close();
    }

    private void runApexPofiling() {
        Profiler profiler = new ApexProfiler();
        String profilingReport = profiler.generateProfilingReport();
        if (profiler.isBreachingWarning()) {
            warn(profilingReport);
        } else {
            info(profilingReport);
        }
    }
}
```


File `main\utilities\logging\classes\LoggerAdapter.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-06-27
 * @group Logging
 * @description The logger adapter exposes the log method and the specific log levels to be implemented by whatever class implements it
 *
 **/
@SuppressWarnings('PMD.ExcessivePublicCount')
public abstract class LoggerAdapter {
    protected String logType;

    public virtual void setType(String type) {
        logType = type;
    }
    public abstract void log(Object logLevel, String message);
    public virtual void log(Object logLevel, String message, Id recordId) {
        message = 'Record Id: ' + recordId + ' message: ' + message;
        log(logLevel, message);
    }
    public abstract Object errorLevel();
    public abstract Object warningLevel();
    public abstract Object infoLevel();
    public abstract Object debugLevel();

    @SuppressWarnings('PMD.EmptyStatementBlock')
    public virtual void close() {
        // by default nothing needed here
    }

    /**
     * Implementation of LoggerAdapter that directs all logging through the built-in Apex method <code>System.debug()</code>
     */
    public class DebugLogAdapter extends LoggerAdapter {
        @SuppressWarnings('PMD.AvoidDebugStatements')
        public override void log(Object logLevel, String message) {
            System.debug((LoggingLevel) logLevel, message);
        }

        public override Object errorLevel() {
            return LoggingLevel.ERROR;
        }
        public override Object warningLevel() {
            return LoggingLevel.WARN;
        }
        public override Object infoLevel() {
            return LoggingLevel.INFO;
        }
        public override Object debugLevel() {
            return LoggingLevel.DEBUG;
        }
    }
}
```


File `main\utilities\logging\classes\LoggerFactory.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-11-20
 * @group Logging
 * @description This factory class is used to abstract away the creation of the Logger and which adapter it is using,
 * which will allow for the adapters to be swapped out easier
 *
 **/
public with sharing class LoggerFactory {
    public static Logger createLogger(Type apexClass) {
        return new Logger(apexClass, EventBufferLogAdapter.getInstance());
    }
}
```


File `main\utilities\logging\classes\LogMessage.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-11-20
 * @group Logging
 * @description This class holds the logic for generating log messages,
 * meaning any specific details that should be added to each log can be appended in here
 *
 **/
public class LogMessage {
    private final String message;
    private String stackTraceString;

    public LogMessage(String message) {
        this.message = message;
    }

    public LogMessage(Exception exceptionToLog) {
        this.message = exceptionToLog.getMessage();
        this.stackTraceString = exceptionToLog.getStackTraceString();
    }

    public String getStackTraceString() {
        if (String.isBlank(stackTraceString)) {
            stackTraceString = generateStackTraceString();
        }
        return stackTraceString;
    }

    private String generateStackTraceString() {
        List<String> stack = (new DmlException()).getStackTraceString().split('\n');
        while (isLoggingFrameworkClass(stack[0])) {
            stack.remove(0);
        }
        return String.join(stack, '\n');
    }

    private Boolean isLoggingFrameworkClass(String stackLine) {
        return stackLine.startsWith('Class.Logger.') ||
            stackLine.startsWith('Class.LoggerAdapter.') ||
            stackLine.startsWith('Class.LogMessage.');
    }

    public override String toString() {
        return String.format(
            '{0}\nStack trace:\n{1}',
            new List<String>{ message, getStackTraceString() }
        );
    }
}
```


File `main\utilities\logging\classes\LogWriter.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-04-20
 * @group Logging
 * @description The LogWriter class converts log events into log sobjects so that they are perminantely committed into the database
 *
 **/
public without sharing class LogWriter extends Triggerable {
    private final List<Log__c> logs = new List<Log__c>();

    public override void register(SObjectTriggerWrapper wrappedSObject) {
        Log_Event__e logEvent = (Log_Event__e) wrappedSObject.getSObject();
        logs.add(
            new Log__c(
                Level__c = logEvent.Level__c,
                Messages__c = logEvent.Messages__c,
                Record_Id__c = logEvent.Record_Id__c,
                Type__c = logEvent.Type__c,
                Quiddity__c = logEvent.Quiddity__c,
                Transaction_Id__c = logEvent.Transaction_Id__c
            )
        );
    }

    public override void performAction() {
        insert logs;
        // don't error handle as we assume no errors will occur
    }
}
```


File `main\utilities\logging\classes\QueueableScheduler.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-03-11
 * @group Logging
 * @description This class will schedule a queuebale class to run by injecting the queuebale into the class
 * Usage:
 * QueueableScheduler scheduler = new QueueableScheduler(new MyQueueable());
 * scheduler.scheduleDaily();
 *
 **/
public inherited sharing class QueueableScheduler extends LoggedSchedulable {
    private final LoggedQueueable queueableToRun;
    private Id runningQueueableId;

    public QueueableScheduler(LoggedQueueable queueableToRun) {
        this.queueableToRun = queueableToRun;
    }

    public override void execute() {
        runningQueueableId = queueableToRun.enqueue();
    }

    public Id getRunningQueueableId() {
        return runningQueueableId;
    }
}
```


File `main\utilities\logging\profiler\classes\ApexProfiler.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-02-02
 * @group Logging
 * @description This class is used to log out the profiling information of the current running transaction.
 *  This will log out as part of the trigger framework after any transaction if any of the limits are approaching 75%
 *
 **/
public without sharing class ApexProfiler extends Profiler {
    public override void refreshProfiling() {
        addProfilingInfo(
            'AggregateQueries',
            Limits.getAggregateQueries(),
            Limits.getLimitAggregateQueries()
        );
        addProfilingInfo('Callouts', Limits.getCallouts(), Limits.getLimitCallouts());
        addProfilingInfo('CpuTime', Limits.getCpuTime(), Limits.getLimitCpuTime());
        addProfilingInfo('DatabaseTime', Limits.getDatabaseTime(), Limits.getLimitDatabaseTime());
        addProfilingInfo('DmlRows', Limits.getDmlRows(), Limits.getLimitDmlRows());
        addProfilingInfo(
            'DmlStatements',
            Limits.getDmlStatements(),
            Limits.getLimitDmlStatements()
        );
        addProfilingInfo(
            'EmailInvocations',
            Limits.getEmailInvocations(),
            Limits.getLimitEmailInvocations()
        );
        addProfilingInfo(
            'FindSimilarCalls',
            Limits.getFindSimilarCalls(),
            Limits.getLimitFindSimilarCalls()
        );
        addProfilingInfo('FutureCalls', Limits.getFutureCalls(), Limits.getLimitFutureCalls());
        addProfilingInfo('HeapSize', Limits.getHeapSize(), Limits.getLimitHeapSize());
        addProfilingInfo(
            'MobilePushApexCalls',
            Limits.getMobilePushApexCalls(),
            Limits.getLimitMobilePushApexCalls()
        );
        addProfilingInfo('Queries', Limits.getQueries(), Limits.getLimitQueries());
        addProfilingInfo(
            'QueryLocatorRows',
            Limits.getQueryLocatorRows(),
            Limits.getLimitQueryLocatorRows()
        );
        addProfilingInfo('QueryRows', Limits.getQueryRows(), Limits.getLimitQueryRows());
        addProfilingInfo(
            'QueueableJobs',
            Limits.getQueueableJobs(),
            Limits.getLimitQueueableJobs()
        );
        addProfilingInfo('RunAs', Limits.getRunAs(), Limits.getLimitRunAs());
        addProfilingInfo(
            'SavepointRollbacks',
            Limits.getSavepointRollbacks(),
            Limits.getLimitSavepointRollbacks()
        );
        addProfilingInfo('Savepoints', Limits.getSavepoints(), Limits.getLimitSavepoints());
        addProfilingInfo('SoslQueries', Limits.getSoslQueries(), Limits.getLimitSoslQueries());
        addProfilingInfo(
            'PublishImmediateDML',
            Limits.getPublishImmediateDML(),
            Limits.getLimitPublishImmediateDML()
        );
    }
}
```


File `main\utilities\logging\profiler\classes\OrgLimitsProfiler.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-10-08
 * @group Logging
 * @description This class runs the profiling for org limits
 *
 **/
public without sharing class OrgLimitsProfiler extends Profiler {
    public override void refreshProfiling() {
        Map<String, OrgLimit> orgLimitsMap = OrgLimits.getMap();
        for (String limitName : orgLimitsMap.keySet()) {
            OrgLimit orgLimit = orgLimitsMap.get(limitName);
            addProfilingInfo(limitName, orgLimit.getValue(), orgLimit.getLimit());
        }
    }
}
```


File `main\utilities\logging\profiler\classes\OrgLimitsProfilingReportRunner.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-10-06
 * @group Logging
 * @description This class will run the full profiling (ie including the org limits), and write into the logs.
 *  To run you can execute:
 * OrgLimitsProfilingReportRunner report = new OrgLimitsProfilingReportRunner();
 * report.scheduleDaily();
 *
 **/
public without sharing class OrgLimitsProfilingReportRunner extends LoggedSchedulable {
    public static final String JOB_NAME = 'Profiling Report';
    public static final String LOG_TYPE = 'Org Limits Profiling Report';

    private final Profiler profiler = new OrgLimitsProfiler();

    public OrgLimitsProfilingReportRunner() {
        setJobName(JOB_NAME);
    }

    public override void execute() {
        log.setType(LOG_TYPE);
        if (profiler.isBreachingWarning()) {
            log.warn(profiler.generateProfilingReport());
        } else {
            log.info(profiler.generateProfilingReport());
        }
        log.close();
    }
}
```


File `main\utilities\logging\profiler\classes\Profiler.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-10-08
 * @group Logging
 * @description This is a generic profiling class, which allows implementations to report on certain limits within the environment.
 *
 **/
public abstract without sharing class Profiler {
    @testVisible
    private static final Decimal DEFAULT_WARNING_PERCENTAGE = 0.75;
    @testVisible
    private final Map<String, ProfileInfo> profilingInfos = new Map<String, ProfileInfo>();
    private Boolean isBreachingWarning = false;
    private static final Map<String, Decimal> WARNING_PERCENTAGES = new Map<String, Decimal>();
    private static final Set<String> IGNORE_LIMITS = new Set<String>();

    static {
        for (Apex_Profiling_Warning_Limit__mdt warningLimit : [
            SELECT DeveloperName, Ignore_Limit__c, Warning_Level__c
            FROM Apex_Profiling_Warning_Limit__mdt
        ]) {
            if (warningLimit.Ignore_Limit__c) {
                IGNORE_LIMITS.add(warningLimit.DeveloperName);
            } else {
                WARNING_PERCENTAGES.put(warningLimit.DeveloperName, warningLimit.Warning_Level__c);
            }
        }
    }

    public Profiler() {
        refreshProfiling();
    }

    public Boolean isBreachingWarning() {
        return isBreachingWarning;
    }

    /**
     * @description This method should be implemented in the base classes to refresh the profiling limits,
     * this will be called from the constructor and then at any point before this is planned to execute
     *
     **/
    public abstract void refreshProfiling();

    protected void addProfilingInfo(String limitName, Integer recorded, Integer limitTotal) {
        if (!IGNORE_LIMITS.contains(limitName)) {
            ProfileInfo profilingInfo = new ProfileInfo(limitName, recorded, limitTotal);
            isBreachingWarning = isBreachingWarning || profilingInfo.isBreachingWarning();
            profilingInfos.put(profilingInfo.limitName, profilingInfo);
        }
    }

    /**
     * @description This method is used to generate the report, each line that is breeching the warning will be marked as Warning
     *
     **/
    public String generateProfilingReport() {
        StringBuilder report = new StringBuilder();
        report.setSeparator('\n');
        for (ProfileInfo profile : profilingInfos.values()) {
            report.append(profile.getReportLine());
        }
        return report.toString();
    }

    private class ProfileInfo {
        private final String limitName;
        @testVisible
        private final Integer recorded;
        @testVisible
        private final Integer limitTotal;

        private ProfileInfo(String limitName, Integer recorded, Integer limitTotal) {
            this.limitName = limitName;
            this.recorded = recorded;
            this.limitTotal = limitTotal;
        }

        private Decimal getPercentage() {
            return limitTotal == 0
                ? 0
                : 1 - Decimal.valueOf(limitTotal - recorded) / Decimal.valueOf(limitTotal);
        }

        private String getReportLine() {
            String prefix = isBreachingWarning() ? 'Warning hit for ' : 'Number of ';
            return prefix + limitName + ': ' + recorded + ' of ' + limitTotal;
        }

        private Boolean isBreachingWarning() {
            Decimal warningPercentage = WARNING_PERCENTAGES.containsKey(limitName)
                ? (WARNING_PERCENTAGES.get(limitName) / 100)
                : DEFAULT_WARNING_PERCENTAGE;
            return getPercentage() > warningPercentage;
        }
    }
}
```


File `main\utilities\logging\triggers\LogEventAfterInsert.trigger`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-04-20
 *
 **/
trigger LogEventAfterInsert on Log_Event__e(after insert) {
    TriggerDispatcher.run(new List<Triggerable>{ new LogWriter() });
}
```


File `main\utilities\parsers\classes\DisplayTypeParser.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-03-23
 * @group Parsers
 * @description This parser will take a string value and convert it to the display type that is passed into the constructor
 *
 **/
public class DisplayTypeParser implements Parsable {
    private static final Map<DisplayType, Parser> PARSERS = new Map<DisplayType, Parser>{
        DisplayType.BOOLEAN => new BooleanParser(),
        DisplayType.DOUBLE => new DecimalParser(),
        DisplayType.CURRENCY => new DecimalParser(),
        DisplayType.PERCENT => new DecimalParser(),
        DisplayType.INTEGER => new DecimalParser(),
        DisplayType.DATE => new DateParser(),
        DisplayType.DATETIME => new DatetimeParser(),
        DisplayType.ID => new IdParser(),
        DisplayType.REFERENCE => new IdParser(),
        null => new StringParser()
    };

    private final Parser parser;

    public DisplayTypeParser(DisplayType type) {
        parser = PARSERS.containsKey(type) ? PARSERS.get(type) : PARSERS.get(null);
    }

    /*
     * @example
     * DescribeFieldResult field = Account.NumberOfEmployees.getDescribe(); // this would be more dynamic
     * Parsable parser = new DisplayTypeParser(field.getType());
     * Account newAccount = new Account();
     * newAccount.put(field.getName(), parser.parse('100'));
     */
    public Object parse(String value) {
        return parser.parse(value);
    }

    private abstract class Parser {
        public Object parse(String value) {
            Object parsedValue;
            if (String.isNotBlank(value)) {
                parsedValue = parseSafe(value);
            }
            return parsedValue;
        }
        protected abstract Object parseSafe(String value);
    }
    private class BooleanParser extends Parser {
        protected override Object parseSafe(String value) {
            return Boolean.valueOf(value);
        }
    }
    private class DecimalParser extends Parser {
        protected override Object parseSafe(String value) {
            return Decimal.valueOf(value);
        }
    }
    private class DateParser extends Parser {
        protected override Object parseSafe(String value) {
            return Date.valueOf(value);
        }
    }
    private class DatetimeParser extends Parser {
        protected override Object parseSafe(String value) {
            return Datetime.valueOf(value);
        }
    }
    private class IdParser extends Parser {
        protected override Object parseSafe(String value) {
            return Id.valueOf(value);
        }
    }
    private class StringParser extends Parser {
        protected override Object parseSafe(String value) {
            return String.valueOf(value);
        }
    }
}
```


File `main\utilities\parsers\classes\Parsable.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-03-23
 * @group Parsers
 * @description Parsable interface will be implemented by classes that are intended to parse a string to an object value
 *
 **/
public interface Parsable {
    Object parse(String stringToParse);
}
```


File `main\utilities\schema\classes\InvalidFieldException.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-12-12
 * @group Schema
 * @description This is an exception class that details an invalid filed when accessing the schema
 *
 **/
public class InvalidFieldException extends Exception {
}
```


File `main\utilities\schema\classes\PicklistValueSet.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-02-11
 * @group Schema
 * @description This class will hold the picklist values of an object so that the values can be more easily retrieved
 *
 **/
public class PicklistValueSet {
    private final Map<String, String> apiNameByValues = new Map<String, String>();
    private final Map<String, String> valuesByApiNames = new Map<String, String>();
    private final DescribeFieldResult fieldDefinition;

    public PicklistValueSet(DescribeFieldResult fieldDefinition) {
        this.fieldDefinition = fieldDefinition;
        for (Schema.PicklistEntry value : fieldDefinition.getPickListValues()) {
            apiNameByValues.put(value.getValue().toLowerCase(), value.getLabel());
            valuesByApiNames.put(value.getLabel().toLowerCase(), value.getValue());
        }
    }

    public String getValue(String label) {
        return valuesByApiNames.get(label.toLowerCase());
    }

    public String getLabel(String value) {
        return apiNameByValues.get(value.toLowerCase());
    }
}
```


File `main\utilities\schema\classes\Relationship.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-05-29
 * @group Schema
 * @description This is a simple class to swap between the id and relationship refrence field when dynamically refrencing relationship fields
 * Usage:
 * // Can be used if you have the relationship field
 * Relationship accountLookup = Relationship.fromRefrenceField('Account');
 * System.debug(accountLookup.idFieldName); // AccountId
 * // Or if you have the id field
 * accountLookup = Relationship.fromIdField('AccountId');
 * System.debug(accountLookup.referenceFieldName); // Account
 * // Similarly for custom objects
 * accountLookup = Relationship.fromRefrenceField('Account__r');
 * System.debug(accountLookup.idFieldName); // Account__c
 *
 * accountLookup = Relationship.fromIdField('Account__c');
 * System.debug(accountLookup.referenceFieldName); // Account__r
 *
 **/
public with sharing class Relationship {
    public static final String INVALID_RELATIONSHIP_FIELD = 'The field passed in is not a relationship. Field Value: ';

    public final String referenceFieldName;
    public final String idFieldName;

    private Relationship(String referenceFieldName, String idFieldName) {
        this.referenceFieldName = referenceFieldName;
        this.idFieldName = idFieldName;
    }

    public static Relationship fromRefrenceField(String referenceFieldName) {
        String idFieldName;
        if (referenceFieldName.toLowerCase().endsWith('__r')) {
            idFieldName = referenceFieldName.replaceAll('(?i)__r', '__c');
        } else {
            // cannot really check for any errors here, just have to trust it is correct
            idFieldName = referenceFieldName + 'Id';
        }
        return new Relationship(referenceFieldName, idFieldName);
    }

    public static Relationship fromIdField(String idFieldName) {
        String referenceFieldName;
        if (idFieldName.toLowerCase().endsWith('__c')) {
            referenceFieldName = idFieldName.replaceAll('(?i)__c', '__r');
        } else if (idFieldName.toLowerCase().endsWith('id')) {
            // cannot really check for any errors here, just have to trust it is correct
            referenceFieldName = idFieldName.replaceAll('(?i)id', '');
        } else {
            throw new InvalidFieldException(INVALID_RELATIONSHIP_FIELD + idFieldName);
        }
        return new Relationship(referenceFieldName, idFieldName);
    }
}
```


File `main\utilities\schema\classes\SchemaFacade.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-02-02
 * @group Schema
 * @description This is a facade for the schema describe functions to make accessing the schema much easier within apex.
 * It is implemented as a sigleton so that it can perform some form of cacheing,
 * this probably isn't nessisary as I think salesforce implements cacheing on the schema methods anyway,
 * but this is just to be safe
SchemaFacade schema = SchemaFacade.getInstance();
DescribeSObjectResult accountDescribe = schema.getDescribe('Account');
System.debug(accountDescribe.getName());

DescribeFieldResult fieldDescribe = schema.getFieldDescribe('Account', 'Name');
System.debug(fieldDescribe.getName());
 *
 **/
public without sharing class SchemaFacade {
    private Map<String, SObjectType> sObjectTypeByObjectNames = Schema.getGlobalDescribe();
    private Map<String, DescribeSObjectResult> sObjectDescribeByObjectNames = new Map<String, DescribeSObjectResult>();
    private Map<String, Map<String, SObjectField>> fieldTypesByNameAndObject = new Map<String, Map<String, SObjectField>>();
    private Map<String, Map<String, DescribeFieldResult>> fieldDescribeByNameAndObject = new Map<String, Map<String, DescribeFieldResult>>();

    private static final SchemaFacade INSTANCE = new SchemaFacade();

    public static SchemaFacade getInstance() {
        return INSTANCE;
    }

    @SuppressWarnings('PMD.EmptyStatementBlock')
    private SchemaFacade() {
    }

    public Boolean isValidSObject(String objectApiName) {
        return sObjectTypeByObjectNames.containsKey(objectApiName);
    }

    public Boolean isNotValidSObject(String objectApiName) {
        return !isValidSObject(objectApiName);
    }

    /*
     * @description will provide the describe sobject result for the object name specified,
     * this method will travers the SObjectType so this doesn't have to be considered
     */
    public DescribeSObjectResult getDescribe(String objectApiName) {
        objectApiName = objectApiName.toLowerCase();
        validateObjectApiName(objectApiName);
        if (!sObjectDescribeByObjectNames.containsKey(objectApiName)) {
            DescribeSObjectResult sObjectDescribe = sObjectTypeByObjectNames.get(objectApiName)
                .getDescribe(SObjectDescribeOptions.FULL);
            sObjectDescribe.fields.getMap();
            sObjectDescribeByObjectNames.put(objectApiName, sObjectDescribe);
        }
        return sObjectDescribeByObjectNames.get(objectApiName);
    }

    private void validateObjectApiName(String objectApiName) {
        if (isNotValidSObject(objectApiName)) {
            throw new InvalidDescribeException('The field ' + objectApiName + ' does not exist');
        }
    }

    public Boolean isValidField(String objectApiName, String fieldApiName) {
        return isValidSObject(objectApiName) &&
            getFieldsMap(objectApiName).containsKey(fieldApiName);
    }

    public Boolean isNotValidField(String objectApiName, String fieldApiName) {
        return !isValidField(objectApiName, fieldApiName);
    }

    @SuppressWarnings('PMD.EagerlyLoadedDescribeSObjectResult')
    private Map<String, SObjectField> getFieldsMap(String objectApiName) {
        objectApiName = objectApiName.toLowerCase();
        validateObjectApiName(objectApiName);
        if (!fieldTypesByNameAndObject.containsKey(objectApiName)) {
            Map<String, SObjectField> fieldsMap = getDescribe(objectApiName).fields.getMap();
            fieldTypesByNameAndObject.put(objectApiName, fieldsMap);
        }
        return fieldTypesByNameAndObject.get(objectApiName);
    }

    /*
     * @description retrieves the field describe for the object and field name provided,
     * it will traverse the SObjectField's so you don't have to
     */
    @SuppressWarnings('PMD.EagerlyLoadedDescribeSObjectResult')
    public DescribeFieldResult getFieldDescribe(String objectApiName, String fieldApiName) {
        objectApiName = objectApiName.toLowerCase();
        fieldApiName = fieldApiName.toLowerCase();
        validateFieldApiName(objectApiName, fieldApiName);
        if (
            !fieldDescribeByNameAndObject.containsKey(objectApiName) ||
            !fieldDescribeByNameAndObject.get(objectApiName).containsKey(fieldApiName)
        ) {
            Map<String, DescribeFieldResult> fieldDescribeMap = fieldDescribeByNameAndObject.get(
                objectApiName
            );
            fieldDescribeMap = fieldDescribeMap == null
                ? new Map<String, DescribeFieldResult>()
                : fieldDescribeMap;
            fieldDescribeMap.put(
                fieldApiName,
                getFieldsMap(objectApiName).get(fieldApiName).getDescribe()
            );
            fieldDescribeByNameAndObject.put(objectApiName, fieldDescribeMap);
        }
        return fieldDescribeByNameAndObject.get(objectApiName).get(fieldApiName);
    }

    private void validateFieldApiName(String objectApiName, String fieldApiName) {
        if (isNotValidField(objectApiName, fieldApiName)) {
            throw new InvalidDescribeException(
                'The field ' +
                fieldApiName +
                ' does not exist on the object ' +
                objectApiName
            );
        }
    }

    public class InvalidDescribeException extends Exception {
    }
}
```


File `main\utilities\schema\classes\SecureSObjectWrapper.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-03-23
 * @group Schema
 * @description This class is a secure wrapper for the sobject that obeys field level security
 * for the user accessing it. This wraps <<SObjectWrapper>> so the recursive retrieves will be enabled
 *
 **/
public class SecureSObjectWrapper extends SObjectWrapper {
    public SecureSObjectWrapper(SObject sObjectToWrap) {
        super(sObjectToWrap);
    }

    /*
     * @description get will retrieve the field if it is visible to the user, otherwise it will return null
     */
    public override Object get(String fieldApiName) {
        DescribeFieldResult field = describe(fieldApiName);
        if (field.isAccessible()) {
            return super.get(fieldApiName);
        }
        return null;
    }

    /*
     * @description the put will only allow writing if the field is createable and updateable by the user
     */
    public override void put(String fieldApiName, Object fieldValue) {
        DescribeFieldResult field = describe(fieldApiName);
        if (field.isCreateable() && field.isUpdateable()) {
            super.put(fieldApiName, fieldValue);
        }
    }
}
```


File `main\utilities\schema\classes\SObjectRecordTypes.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-09-24
 * @group Schema
 * @description Utility class to help make interacting with an objects record types slightly easier eg cal call
 * SObjectRecordTypes opportunityRecordTypes = new SObjectRecordTypes('Opportunity');
 * Id defaultOpportunityRecordTypeId = opportunityRecordTypes.getDefaultId();
 *
 **/
public inherited sharing class SObjectRecordTypes {
    private final Map<String, Schema.RecordTypeInfo> recordTypesByDeveloperName;
    private final Map<Id, Schema.RecordTypeInfo> recordTypesById;
    private RecordTypeInfo defaultRecordTypeInfo;

    @SuppressWarnings('PMD.EagerlyLoadedDescribeSObjectResult')
    public SObjectRecordTypes(final String objectApiName) {
        final SchemaFacade schema = SchemaFacade.getInstance();
        final DescribeSObjectResult objectDescribe = schema.getDescribe(objectApiName);
        recordTypesByDeveloperName = objectDescribe.getRecordTypeInfosByDeveloperName();
        recordTypesById = objectDescribe.getRecordTypeInfosById();
    }

    /*
     * @description retrieves the default record type id for the object specified
     */
    public Id getDefaultId() {
        if (defaultRecordTypeInfo == null) {
            for (Schema.RecordTypeInfo info : recordTypesByDeveloperName.values()) {
                if (info.isDefaultRecordTypeMapping()) {
                    defaultRecordTypeInfo = info;
                    break;
                }
            }
        }
        return defaultRecordTypeInfo.getRecordTypeId();
    }

    /*
     * @description gets the record type id for the developer name specified
     */
    public Id getRecordTypeId(final String developerName) {
        Id recordTypeId;
        if (recordTypesByDeveloperName.containsKey(developerName)) {
            recordTypeId = recordTypesByDeveloperName.get(developerName).getRecordTypeId();
        }
        return recordTypeId;
    }

    /*
     * @description gets the developername for the record type id specified
     */
    public String getRecordTypeDeveloperName(final Id recordTypeId) {
        String recordTypeDeveloperName;
        if (recordTypesById.containsKey(recordTypeId)) {
            recordTypeDeveloperName = recordTypesById.get(recordTypeId).getDeveloperName();
        }
        return recordTypeDeveloperName;
    }
}
```


File `main\utilities\schema\classes\SObjectWrapper.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2019-03-23
 * @group Schema
 * @description This is a wrapper around the SObject class that its primary function is to be able
 * to retrieve parent fields dynamically
 * Usage:
 * Account myContact = [SELECT Account.Name FROM Contact LIMIT 1];
 * SObjectWrapper wrappedContact = new SObjectWrapper(myContact);
 * String accountName = (String) wrappedContact.get('Account.Name');
 *
 **/
public virtual class SObjectWrapper {
    public static final String INVALID_PARENT_MESSAGE = 'The provided field is not a valid relationship field';
    public static final String NON_INITIALISED_RELATIONSHIP = 'The relationship field that is attempting to be accessed has not been initialised.';

    private final SObject wrappedSObject;
    private final String objectApiName;
    private final SchemaFacade schema = SchemaFacade.getInstance();

    public SObjectWrapper(SObject sObjectToWrap) {
        wrappedSObject = sObjectToWrap;
        objectApiName = String.valueOf(sObjectToWrap.getSObjectType());
    }

    /*
     * @description get will recursively retrieve fields from parent objects
     * @example
     * Account myContact = [SELECT Account.Name FROM Contact LIMIT 1];
     * SObjectWrapper wrappedContact = new SObjectWrapper(myContact);
     * String accountName = (String) wrappedContact.get('Account.Name');
     */
    public virtual Object get(String fieldApiName) {
        if (isRelatedField(fieldApiName)) {
            return getParentField(wrappedSObject, fieldApiName);
        }
        return wrappedSObject.get(fieldApiName);
    }

    public virtual void put(String fieldApiName, Object fieldValue) {
        wrappedSObject.put(fieldApiName, fieldValue);
    }

    private static Boolean isRelatedField(String fieldApiName) {
        return fieldApiName.contains('.');
    }

    private static Object getParentField(SObject childSObject, String fieldApiName) {
        RelationshipField field = new RelationshipField(fieldApiName);
        SObject parentSObject;
        try {
            // this is a peculiar error that is thrown only on the second parent if is not initialised (first parent is fine)
            parentSObject = childSObject.getSobject(field.relationshipApiName);
        } catch (NullPointerException exceptionToHandle) {
            throw new InvalidFieldException(NON_INITIALISED_RELATIONSHIP);
        }
        if (isRelatedField(field.relatedFieldName)) {
            return getParentField(parentSObject, field.relatedFieldName);
        }
        return parentSObject.get(field.relatedFieldName);
    }

    public DescribeFieldResult describe(String fieldApiName) {
        if (isRelatedField(fieldApiName)) {
            return describeParentField(fieldApiName);
        }
        return describeField(fieldApiName);
    }

    private DescribeFieldResult describeParentField(String fieldApiName) {
        RelationshipField relatedField = new RelationshipField(fieldApiName);
        String parentObjectName = getRelatedObjectName(relatedField.relationshipApiName);
        if (isRelatedField(relatedField.relatedFieldName)) {
            return describeParentField(relatedField.relatedFieldName);
        }
        return schema.getFieldDescribe(parentObjectName, relatedField.relatedFieldName);
    }

    @testVisible
    private String getRelatedObjectName(String relationshipApiName) {
        String relationshipFieldName = Relationship.fromRefrenceField(relationshipApiName)
            .idFieldName;
        DescribeFieldResult relationshipField = schema.getFieldDescribe(
            objectApiName,
            relationshipFieldName
        );
        return relationshipField.getReferenceTo()[0]
            .getDescribe(SObjectDescribeOptions.DEFERRED)
            .getName();
    }

    private DescribeFieldResult describeField(String fieldApiName) {
        return schema.getFieldDescribe(objectApiName, fieldApiName);
    }

    @testVisible
    private class RelationshipField {
        public final String relationshipApiName;
        public final String relatedFieldName;

        public RelationshipField(String fieldApiName) {
            validateParentField(fieldApiName);
            final List<String> parentRelationshipAndField = fieldApiName.split('\\.', 2);
            relationshipApiName = parentRelationshipAndField[0];
            relatedFieldName = parentRelationshipAndField[1];
        }

        private void validateParentField(String fieldApiName) {
            if (!isRelatedField(fieldApiName)) {
                throw new InvalidFieldException(INVALID_PARENT_MESSAGE);
            }
        }
    }
}
```


File `main\utilities\schema\classes\StateCountryCodeMapper.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-02-11
 * @group Schema
 * @description This class is used to get around a salesforce bug where the state/country field is not updated in a trigger, rather the state code is.
 * Other code in the org has been written to rely on the state/country field rather than the code
 *
 **/
public with sharing class StateCountryCodeMapper extends Triggerable {
    @SuppressWarnings('PMD.EagerlyLoadedDescribeSObjectResult')
    private final PicklistValueSet stateValueSet = new PicklistValueSet(
        Account.BillingStateCode.getDescribe()
    );
    @SuppressWarnings('PMD.EagerlyLoadedDescribeSObjectResult')
    private final PicklistValueSet countryValueSet = new PicklistValueSet(
        Account.BillingCountryCode.getDescribe()
    );

    public override void register(SObjectTriggerWrapper wrappedSObject) {
        Account accountRecord = (Account) wrappedSObject.getSObject();
        accountRecord.BillingState = stateValueSet.getLabel(accountRecord.BillingStateCode);
        accountRecord.BillingCountry = countryValueSet.getLabel(accountRecord.BillingCountryCode);
    }
}
```


File `main\utilities\string-utilities\classes\CsvBuilder.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-06-28
 * @group String Utilities
 * @description The CsvBuilder is used to build csv files from some input
 *
 **/
public class CsvBuilder {
    public static final String WINDOWS_LINE_ENDING = '\r\n';
    public static final String UNIX_LINE_ENDING = '\n';

    @testVisible
    private final Map<String, Map<Integer, String>> headerToValues = new Map<String, Map<Integer, String>>();
    private Integer currentRow = 0;
    private final String lineEnding;

    public CsvBuilder(String lineEnding) {
        this.lineEnding = lineEnding;
    }

    public CsvBuilder() {
        this(UNIX_LINE_ENDING);
    }

    /**
     * @description append field will add a field into the existing CSV,
     * if nothing is added to a row for a header, it will be left blank
     * @param headerName the header name the field should be added to,
     * if the field does not exist it will be created
     * @param fieldValue The field value that should be added to the header,
     * if the field is already present on the current row it will be overidden
     *
     **/
    public CsvBuilder appendField(String headerName, String fieldValue) {
        headerName = String.isBlank(headerName) ? 'null' : headerName;
        fieldValue = String.isBlank(fieldValue) ? 'null' : fieldValue;
        Map<Integer, String> column = headerToValues.containsKey(headerName)
            ? headerToValues.get(headerName)
            : new Map<Integer, String>();
        column.put(currentRow, fieldValue);
        headerToValues.put(headerName, column);
        return this;
    }

    /**
     * @description This method will move the CSV to processing a new row
     **/
    public CsvBuilder newRow() {
        currentRow++;
        return this;
    }

    public Integer totalRows() {
        return headerToValues.values() != null ? headerToValues.values().size() : 0;
    }

    public override String toString() {
        ColumnBuilder csvDocument = new ColumnBuilder(lineEnding);
        RowBuilder headerRow = new RowBuilder();
        RowBuilder[] rows = new List<RowBuilder>(totalRows());
        for (String headerName : headerToValues.keySet()) {
            headerRow.append(headerName);
            Map<Integer, String> values = headerToValues.get(headerName);
            for (Integer rowIterator = 0; rowIterator <= currentRow; rowIterator++) {
                String value = values.containsKey(rowIterator) ? values.get(rowIterator) : '';
                RowBuilder row = rows[rowIterator];
                if (row == null) {
                    row = new RowBuilder();
                }
                row.append(value);
                rows[rowIterator] = row;
            }
        }
        csvDocument.append(headerRow);
        for (RowBuilder row : rows) {
            csvDocument.append(row);
        }
        return csvDocument.toString();
    }

    private class RowBuilder extends StringBuilder {
        public RowBuilder() {
            setSeparator(',');
        }
    }

    private class ColumnBuilder extends StringBuilder {
        private Integer numberOfColumns;

        public ColumnBuilder(String lineEnding) {
            setSeparator(lineEnding);
        }

        public ColumnBuilder append(RowBuilder rowToAdd) {
            Boolean isAddedRowValid =
                numberOfColumns == null ||
                rowToAdd.capacity() == numberOfColumns;
            if (!isAddedRowValid) {
                throw new InvalidRowException(
                    'The number of columns provided does not match those already in the csv'
                );
            }
            numberOfColumns = rowToAdd.capacity();
            append(rowToAdd.toString());
            return this;
        }
    }

    public class InvalidRowException extends Exception {
    }
}
```


File `main\utilities\string-utilities\classes\QueryBuilder.cls`:
```apex
/**
 * @author Gavin Palmer <gavinhughpalmer@gmail.com>
 * @date 2019-06-04
 * @group String Utilities
 * @description This class can be used to build up dynamic soql queries
 *
 */
public virtual class QueryBuilder {
    private static final String SOQL_QUERY_STRUCTURE = 'SELECT {0} FROM {1}';
    protected final String objectName;
    private final Set<String> fieldsToQuery = new Set<String>();
    protected final SchemaFacade schema = SchemaFacade.getInstance();
    protected final DescribeSObjectResult objectDescribe;

    @SuppressWarnings('PMD.EagerlyLoadedDescribeSObjectResult')
    protected QueryBuilder(String objectName) {
        validateObjectName(objectName);
        this.objectName = objectName;
        objectDescribe = schema.getDescribe(objectName);
    }

    public static QueryBuilder fromObject(String objectName) {
        return new QueryBuilder(objectName);
    }

    private void validateObjectName(String objectName) {
        if (schema.isNotValidSObject(objectName)) {
            throw new QueryException('The object name \'' + objectName + '\' is not valid');
        }
    }

    public QueryBuilder selectField(String field) {
        fieldsToQuery.add(field.toLowerCase());
        return this;
    }

    public QueryBuilder selectFields(List<String> fields) {
        for (String field : fields) {
            selectField(field);
        }
        return this;
    }

    public QueryBuilder selectFieldSet(String fieldSetName) {
        for (
            Schema.FieldSetMember member : objectDescribe.FieldSets.getMap()
                .get(fieldSetName)
                .getFields()
        ) {
            selectField(member.getFieldPath());
        }
        return this;
    }

    public QueryBuilder selectAllFields() {
        // should still be used over the FIELDS(ALL) method, to return all fields not just those the user has access to
        for (String field : objectDescribe.fields.getMap().keySet()) {
            selectField(field);
        }
        return this;
    }

    public QueryBuilder selectAllAccessibleFields() {
        selectField('FIELDS(ALL)');
        return this;
    }

    public override String toString() {
        validateFields();
        return String.format(
            SOQL_QUERY_STRUCTURE,
            new List<String>{ String.join(new List<String>(fieldsToQuery), ','), objectName }
        );
    }

    private void validateFields() {
        if (fieldsToQuery.isEmpty()) {
            throw new QueryException(
                'No fields have been added into the query so it cannot be executed'
            );
        }
    }

    public class QueryException extends Exception {
    }
}
```


File `main\utilities\string-utilities\classes\StringBuilder.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-06-28
 * @group String Utilities
 * @description This class is intended to be similar to the java StringBuilder, it allows strings to be dynamically constructed but only assigned at the point, similar to Javas StringBuffer
 *
 **/
public virtual inherited sharing class StringBuilder {
    @testVisible
    private final List<String> buffer;
    @testVisible
    private String separator = '';
    private Integer count = 0;

    @SuppressWarnings('PMD.EmptyStatementBlock')
    public StringBuilder() {
        buffer = new List<String>();
    }

    public StringBuilder(Object value) {
        this();
        append(value);
    }

    public StringBuilder append(String value) {
        if (value != null) {
            buffer.add(value);
            count += value.length();
        }
        return this;
    }

    public StringBuilder append(Object value) {
        String stringValue = String.valueOf(value);
        return append(stringValue);
    }

    public StringBuilder append(StringBuilder stringBuilder) {
        if (stringBuilder == null) {
            return append('null');
        }
        count += stringBuilder.count;
        buffer.addAll(stringBuilder.buffer);
        return this;
    }

    public void setSeparator(String separator) {
        if (String.isNotEmpty(separator)) {
            this.separator = separator;
        }
    }

    /**
     * @description Capacity will return the total numbe of strings in the buffer
     *
     **/
    public Integer capacity() {
        return buffer.size();
    }

    /**
     * @description Length will return the total length of the string once it is combined
     *
     **/
    public Integer length() {
        return count + (separator.length() * (capacity() - 1));
    }

    // TODO
    // delete
    // replace
    // subString
    // insert
    // indexOf
    // lastIndexOf
    // reverse

    public override String toString() {
        return String.join(buffer, separator);
    }
}
```


File `main\utilities\trigger-framework\classes\SObjectTriggerWrapper.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-10-29
 * @group Trigger Framework
 * @description This class is used by the trigger framework to give a few utility methods to the SObjects
 *
 **/
public inherited sharing class SObjectTriggerWrapper {
    private final SObject newSObject;
    private final SObject oldSObject;

    public SObjectTriggerWrapper(SObject newSObject, SObject oldSObject) {
        this.newSObject = newSObject;
        this.oldSObject = oldSObject;
    }

    public Boolean hasChanged(String fieldName) {
        return oldSObject == null || oldSObject.get(fieldName) != newSObject.get(fieldName);
    }

    public Boolean hasChanged(Schema.SObjectField field) {
        return oldSObject == null || oldSObject.get(field) != newSObject.get(field);
    }

    public Boolean hasChangedTo(String fieldName, Object fieldValue) {
        return hasChanged(fieldName) && newSObject.get(fieldName) == fieldValue;
    }

    public Boolean hasChangedTo(Schema.SObjectField field, Object fieldValue) {
        return hasChanged(field) && newSObject.get(field) == fieldValue;
    }

    public SObject getSObject() {
        return newSObject;
    }
}
```


File `main\utilities\trigger-framework\classes\Triggerable.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-06-28
 * @group Trigger Framework
 * @description This interface will be implemented by any action that is used in a trigger,
 * this allows each trigger to loop over the set of records once to complete all the actions in the system.
 * intention is that any initial setup actions can be performed in the constructor (ie set up some required data),
 * then the register will determine if the new record should have any actions performed and add to a private list,
 * then finally the performAction will run any dml / soql, essentially the bulk of the logic
 *
 **/
public abstract class Triggerable {
    /*
     * @description Within the trigger framework, this method will get called once (and only once) for every record entering the trigger.
     * This should be used to build up a list of records that wish to be operated on, or in the case of validation it can run the validation directly.
     */
    public abstract void register(SObjectTriggerWrapper wrappedSObject);

    /*
     * @description this method will be called once for every trigger action,
     * that is after all the records have been iterated over. The use case is for performing any of the
     * DML or SOQL that is required.
     */
    @SuppressWarnings('PMD.EmptyStatementBlock')
    public virtual void performAction() {
        // This allows us to have not implement if not nessisary on extention classes, as without this there were a lot of validation like classes that would have an empty code block
    }
}
```


File `main\utilities\trigger-framework\classes\TriggerDispatcher.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2020-11-18
 * @group Trigger Framework
 * @description This trigger dispatcher will be called from each trigger with a list of triggerable actions to perform.
 *  As the single point of entry for all triggers this class will manage the disabling and enabling of triggers, as well as tracking the stack of triggers
 *
 **/
public with sharing class TriggerDispatcher {
    private static final Stack TRIGGER_STACK = new Stack();
    private static Boolean unknownExceptionLogged = false;
    private static final Set<String> DISABLED_TRIGGERS = new Set<String>();

    private final Triggerable handler;
    private final List<SObject> newSObjects;
    private final Map<Id, SObject> oldMap;
    private final String currentTriggerAction;
    private final Logger log = LoggerFactory.createLogger(TriggerDispatcher.class);

    @SuppressWarnings('PMD.ExcessiveParameterList')
    @TestVisible
    private TriggerDispatcher(
        List<Triggerable> actions,
        List<SObject> newSObjects,
        Map<Id, SObject> oldMap,
        TriggerOperation operation
    ) {
        this.handler = new TriggerHandler(actions);
        // default the map to the old map for delete triggers
        this.newSObjects = newSObjects == null ? oldMap.values() : newSObjects;
        this.oldMap = oldMap;
        this.currentTriggerAction = getTriggerAction(newSObjects.getSObjectType(), operation);
    }

    // Will be difficult to get coverage directly for this method instead we will use the constructor directly
    public static void run(List<Triggerable> actions) {
        (new TriggerDispatcher(actions, Trigger.new, Trigger.oldMap, Trigger.operationType)).run();
    }

    public static void disable(SObjectType objectType, TriggerOperation operation) {
        DISABLED_TRIGGERS.add(getTriggerAction(objectType, operation));
    }

    public static void enable(SObjectType objectType, TriggerOperation operation) {
        DISABLED_TRIGGERS.remove(getTriggerAction(objectType, operation));
    }

    private static String getTriggerAction(SObjectType objectType, TriggerOperation operation) {
        return (operation + '-' + objectType).toUpperCase();
    }

    public void run() {
        if (triggersAreActive()) {
            try {
                TRIGGER_STACK.push(currentTriggerAction);
                executeTriggerables();
                TRIGGER_STACK.pop(); // pop in here so errors will get handled
            } catch (Stack.UnderflowException underflowException) {
                logUnknownException('Stack underflow');
                throw underflowException; // Surface up to users
            } catch (Exception exceptionToHandle) {
                logUnknownException(exceptionToHandle.getMessage());
                TRIGGER_STACK.pop(); // it wasn't popped
                throw exceptionToHandle;
            } finally {
                if (TRIGGER_STACK.isEmpty()) {
                    log.close();
                }
            }
        }
    }

    private void executeTriggerables() {
        for (SObject newSObject : newSObjects) {
            // ensure we don't get any null pointer issues in inserts
            SObject oldSObject = oldMap != null ? oldMap.get(newSObject.Id) : null;
            SObjectTriggerWrapper wrappedSObject = new SObjectTriggerWrapper(
                newSObject,
                oldSObject
            );
            handler.register(wrappedSObject);
        }
        handler.performAction();
    }

    private Boolean triggersAreActive() {
        return ConfigurationManager.getInstance().areTriggersOn() &&
            !DISABLED_TRIGGERS.contains(currentTriggerAction);
    }

    private void logUnknownException(String exceptionMessage) {
        // Only write the logs the first time an unknown exception is thown, the exception will then get thrown all the way up the stack
        if (!unknownExceptionLogged) {
            log.error(
                'Unhandled exception within trigger: ' +
                exceptionMessage +
                '\n' +
                'Trigger Stack: ' +
                TRIGGER_STACK.toString()
            );
            unknownExceptionLogged = true;
        }
    }
}
```


File `main\utilities\trigger-framework\classes\TriggerHandler.cls`:
```apex
/**
 * @author Gavin Palmer
 * @date 2018-06-28
 * @group Trigger Framework
 * @description This class is a grouping of Triggerable actions so that they can be executed as one
 *
 **/
public inherited sharing class TriggerHandler extends Triggerable {
    private final List<Triggerable> triggerActions;

    public TriggerHandler(List<Triggerable> triggerActions) {
        this.triggerActions = triggerActions;
    }

    public override void register(SObjectTriggerWrapper wrappedSObject) {
        for (Triggerable action : triggerActions) {
            action.register(wrappedSObject);
        }
    }

    public override void performAction() {
        for (Triggerable action : triggerActions) {
            action.performAction();
        }
    }
}
```
